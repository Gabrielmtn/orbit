@orbitHeight: 200px;
@orbitWidth: 100%;
@orbitDuration: 5s;
@orbitTransformStyle: preserve-3d;
.orbit {
  padding: 0 0 0 0;
  position:relative;
  margin:  0 0 0 0;
  list-style: none;
  height: 200px;
  width: 400px;
  text-align: center;
  perspective: 600px;
}
.orbit .planet {
  position: absolute;
  left:50%;
  top: 50%;
  margin-top: -30px;
  margin-left: -30px;
  list-style: none;
  font-size: 40px;
  text-align: center;
  line-height: 60px;
  transform-style: @orbitTransformStyle;
  animation-duration: @orbitDuration;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  animation-fill-mode: both;
  transform-origin: center;
}
.orbit [pause-on-hover].planet:not(.center):hover {
  animation-play-state: paused;
}
.orbit:hover .planet:not(.center):hover {
  transform: scale(1.25);
}


// Generate depths, heights, and widths
.genDepth(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-depth="@{i}"] {
    animation-name: ~'goDeep@{i}';
  }
  .genDepth(@n, (@i + 1));
}

.genHeight(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-height="@{i}"] {
    animation-name: ~'goHigh@{i}';
  }
  .genHeight(@n, (@i + 1));
}

.genWidth(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-width="@{i}"] {
    animation-name: ~'goWide@{i}';
  }
  .genWidth(@n, (@i + 1));
}

// But gets tricky here because we need to generate the combos.
.genTernaryDeep(@turn, @round) {
  .genDeep(@n, @i: 1) when (@i <= @n) {
    .orbit .planet[data-orbit-width="@{turn}"][data-orbit-height="@{n}"][data-orbit-depth="@{i}"] {
      animation-name: ~'goWide@{turn}High@{n}Deep@{i}';
    }
    .orbit .planet[data-orbit-width="@{turn}"][data-orbit-depth="@{n}"][data-orbit-height="@{i}"] {
      animation-name: ~'goWide@{turn}Deep@{n}High@{i}';
    } 
    
    .orbit .planet[data-orbit-height="@{turn}"][data-orbit-width="@{n}"][data-orbit-depth="@{i}"] {
      animation-name: ~'goHigh@{turn}Wide@{n}Deep@{i}';
    }
    .orbit .planet[data-orbit-height="@{turn}"][data-orbit-depth="@{n}"][data-orbit-width="@{i}"] {
      animation-name: ~'goHigh@{turn}Deep@{n}Wide@{i}';
    } 
    
    .orbit .planet[data-orbit-depth="@{turn}"][data-orbit-height="@{n}"][data-orbit-width="@{i}"] {
      animation-name: ~'goDeep@{turn}High@{n}Wide@{i}';
    }
    .orbit .planet[data-orbit-depth="@{turn}"][data-orbit-width="@{n}"][data-orbit-height="@{i}"] {
      animation-name: ~'goDeep@{turn}Wide@{n}High@{i}';
    }
    .genDeep(@n, (@i + 1));
  }
  .genDeep(@round);
}
.genTernary(@n, @i: 1) when (@i <= @n) {
  .genTernaryDeep(@n, @i);
  .genTernary(@n, (@i + 1));
}

.genCombo(@n, @i: 1) when (@i <= @n) {
  .orbit .planet[data-orbit-width="@{n}"][data-orbit-height="@{i}"] {
    animation-name: ~'goWide@{n}High@{i}';
  }
  .orbit .planet[data-orbit-width="@{n}"][data-orbit-depth="@{i}"] {
    animation-name: ~'goWide@{n}Deep@{i}';
  }
  .orbit .planet[data-orbit-height="@{n}"][data-orbit-width="@{i}"] {
    animation-name: ~'goHigh@{n}Wide@{i}';
  }
  .orbit .planet[data-orbit-height="@{n}"][data-orbit-depth="@{i}"] {
    animation-name: ~'goHigh@{n}Deep@{i}';
  }
  .orbit .planet[data-orbit-depth="@{n}"][data-orbit-height="@{i}"] {
    animation-name: ~'goDeep@{n}High@{i}';
  }
  .orbit .planet[data-orbit-depth="@{n}"][data-orbit-width="@{i}"] {
    animation-name: ~'goDeep@{n}Wide@{i}';
  }
  .genCombo(@n, (@i + 1));
}
// The ternary must be completed as another loop I think. And not even too sure how to do it.
// .orbit .planet[data-orbit-width="@{n}"][data-orbit-height="@{i}"][data-orbit-depth="@{i}"] {}
.generateTernaryCombos(@n, @i: 1) when (@i <= @n) {
  .genTernary(@i);
  .generateTernaryCombos(@n, (@i + 1));
}
.generateCombos(@n, @i:1) when (@i <= @n) {
  // What does it need to do on this one iteration round.
  // First, we base this on width, the combos being width+height, width+depth and width+depth+height
  .genCombo(@i);
  .generateCombos(@n, (@i + 1));
}

@numberOfPlanets: 4;
.genHeight(@numberOfPlanets);
.genWidth(@numberOfPlanets);
.genDepth(@numberOfPlanets);
.generateCombos(@numberOfPlanets);
.generateTernaryCombos(@numberOfPlanets);

.orbit .planet.center {
  transform: translateZ(0 - @orbitDepthOffset);
  z-index: 1;
}

@orbitDepthOffset: 0px;
.orbit(@depth, @width, @height) {
  .generateOrbit(@n, @i:0) when (@i <= @n) {
    @selector: e('@{i}%');
    @{selector} {
        & when (@i <= 25) {
            transform: translateZ(((@depth / 2) - ((@depth / 50) * (@i))) - @orbitDepthOffset) translateX(0 + ((@width / 50) * @i)) translateY((@height / 2) - ((@height / 50) * (@i)));
            z-index: 0;
        }
        & when (@i > 25) and (@i <= 50) {
            transform: translateZ((0 - ((@depth / 50) * (@i - 25))) - @orbitDepthOffset) translateX((@width / 2) - ((@width / 50) * (@i - 25))) translateY((0 - ((@height / 50) * (@i - 25))));
            z-index: 0;
        }
        & when (@i > 50) and (@i <= 75) {
            transform: translateZ(((-@depth / 2) + ((@depth / 50) * (@i - 50))) - @orbitDepthOffset) translateX(0 - ((@width / 50) * (@i - 50))) translateY((-@height / 2) + ((@height / 50) * (@i - 50)));
            z-index: 2;
        }
        & when (@i > 75) and (@i <= 100) {
            transform: translateZ((0 + ((@depth / 50) * (@i - 75))) - @orbitDepthOffset) translateX(-(@width / 2) + ((@width / 50) * (@i - 75))) translateY(0 + ((@height / 50) * (@i - 75)));
            z-index: 2;
        }
    }
    .generateOrbit(@n, (@i + 1));
  }
  .generateOrbit(100);
}

@orbitDepth: 500px;
@orbitWidth: 500px;


// Generate singular height depth and width orbits
.genHeightOrbits(@n, @i:1) when (@i <= @n) {
  @keyframes ~'goHigh@{i}' {
    @height: (@orbitHeight/@numberOfPlanets) * @i; 
    .orbit(0, 0, @height);
  }
  .genHeightOrbits(@n, (@i + 1));
}

.genWidthOrbits(@n, @i:1) when (@i <= @n) {
  @keyframes ~'goWide@{i}' {
    @width: (@orbitWidth/@numberOfPlanets) * @i;
    .orbit(0, @width, 0);
  }
  .genWidthOrbits(@n, (@i + 1));
}

.genDepthOrbits(@n, @i:1) when (@i <= @n) {
  @keyframes ~'goDeep@{i}' {
    @depth: (@orbitDepth/@numberOfPlanets) * @i;
    .orbit(@depth, 0, 0);
  }
  .genDepthOrbits(@n, (@i + 1));
}

// combo orbit keyframes becomes a little more complicated
.genComboOrbits(@n, @i: 1) when (@i <= @n) {
  @keyframes ~'goWide@{n}High@{i}' {
    @height: (@orbitHeight/@numberOfPlanets) * @i; 
    @width: (@orbitWidth/@numberOfPlanets) * @n;
    .orbit(0, @width, @height);
  }
  @keyframes ~'goWide@{n}Deep@{i}' {
    @depth: (@orbitDepth/@numberOfPlanets) * @i;
    @width: (@orbitWidth/@numberOfPlanets) * @n;
    .orbit(@depth, @width, 0);
  }
  @keyframes ~'goHigh@{n}Wide@{i}' {
    @height: (@orbitHeight/@numberOfPlanets) * @n; 
    @width: (@orbitWidth/@numberOfPlanets) * @i;
    .orbit(0, @width, @height);
  }
  @keyframes ~'goHigh@{n}Deep@{i}' {
    @height: (@orbitHeight/@numberOfPlanets) * @n; 
    @depth: (@orbitDepth/@numberOfPlanets) * @i;
    .orbit(@depth, 0, @height);
  }
  @keyframes ~'goDeep@{n}High@{i}' {
    @height: (@orbitHeight/@numberOfPlanets) * @i; 
    @depth: (@orbitDepth/@numberOfPlanets) * @n;
    .orbit(@depth, 0, @height);
  }
  @keyframes ~'goDeep@{n}Wide@{i}' {
    @depth: (@orbitDepth/@numberOfPlanets) * @n;
    @width: (@orbitWidth/@numberOfPlanets) * @i;
    .orbit(@depth, @width, 0);
  }
  .genComboOrbits(@n, (@i + 1));
}
.generateComboOrbits(@n, @i: 1) when (@i <= @n) {
  .genComboOrbits(@i);
  .generateComboOrbits(@n, (@i + 1));
}

//Ternary combo is of course a bit of a killer but bearable.
.genTernaryOrbitDeep(@turn, @round) {
  .genOrbitDeep(@n, @i: 1) when (@i <= @n) {
    @keyframes ~'goWide@{turn}High@{n}Deep@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @i;
      @width: (@orbitWidth/@numberOfPlanets) * @turn;
      @height: (@orbitHeight/@numberOfPlanets) * @n;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goWide@{turn}Deep@{n}High@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @n;
      @width: (@orbitWidth/@numberOfPlanets) * @turn;
      @height: (@orbitHeight/@numberOfPlanets) * @i;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goHigh@{turn}Wide@{n}Deep@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @i;
      @width: (@orbitWidth/@numberOfPlanets) * @n;
      @height: (@orbitHeight/@numberOfPlanets) * @turn;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goHigh@{turn}Deep@{n}Wide@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @n;
      @width: (@orbitWidth/@numberOfPlanets) * @i;
      @height: (@orbitHeight/@numberOfPlanets) * @turn;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goDeep@{turn}High@{n}Wide@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @turn;
      @width: (@orbitWidth/@numberOfPlanets) * @i;
      @height: (@orbitHeight/@numberOfPlanets) * @n;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goDeep@{turn}Wide@{n}High@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @turn;
      @width: (@orbitWidth/@numberOfPlanets) * @i;
      @height: (@orbitHeight/@numberOfPlanets) * @n;
      .orbit(@depth, @width, @height);
    }
    .genOrbitDeep(@n, (@i + 1));
  }
  .genOrbitDeep(@round);
}
.genTernaryOrbit(@n, @i: 1) when (@i <= @n) {
  .genTernaryOrbitDeep(@n, @i);
  .genTernaryOrbit(@n, (@i + 1));
}
.generateTernaryComboOrbits(@n, @i: 1) when (@i <= @n) {
  .genTernaryOrbit(@i);
  .generateTernaryComboOrbits(@n, (@i + 1));
}
// END TERNARY COMBO GEN

.genHeightOrbits(@numberOfPlanets);
.genWidthOrbits(@numberOfPlanets);
.genDepthOrbits(@numberOfPlanets);
.generateComboOrbits(@numberOfPlanets);
.generateTernaryComboOrbits(@numberOfPlanets);