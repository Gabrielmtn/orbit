@orbitContainerHeight: 200px;
@orbitContainerWidth: 350px;
// These variables determine what is created and the magnitudes of what is created. However I think that variables need renaming etc.
@numberOfPlanets: 4;
@orbitDepth: 1000px;
@orbitWidth: 100%;
@orbitHeight: 100%;
@orbitDepthOffset: 0px;
// The planet width is calculated in a way such that each will be of equal size in order to calculate an accurate width for the container.
@planetWidth: @orbitContainerWidth / ((@numberOfPlanets * 2) + 1);
@orbitPerspective: 600px;
@orbitDuration: 5s;
@orbitTransformStyle: preserve-3d;

.orbit {
  padding: 0 0 0 0;
  position: relative;
  margin:  0 0 0 0;
  list-style: none;
  height: @orbitContainerHeight;
  width: @orbitContainerWidth;
  text-align: center;
  perspective: @orbitPerspective;
}
.orbit .planet {
  position: absolute;
  left:50%;
  top: 50%;
  font-size: 60px;
  margin-top: -(@planetWidth / 2);
  margin-left: -(@planetWidth / 2);
  list-style: none;
  text-align: center;
  transform-style: @orbitTransformStyle;
  animation-duration: @orbitDuration;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  animation-fill-mode: both;
  transform-origin: center;
  width: @planetWidth;
  height: @planetWidth;
}

.orbit .planet.center {
  transform: translateZ(0 - @orbitDepthOffset);
  z-index: 1;
}

// Enables planets to be paused on hover(tap on mobile)
.orbit [pause-on-hover].planet:not(.center):hover {
  animation-play-state: paused;
}
.orbit:hover .planet:not(.center):hover {
  transform: scale(1.25);
  color: red;
}


// Orbit is mostly implemented using a series of loops based on the range of magnitudes (or number of planets) you wish to use.
// It calculates all the different combinations of depth, width, and height to give a range of combinations that can be used.
.genHeight(@numberOfPlanets);
.genWidth(@numberOfPlanets);
.genDepth(@numberOfPlanets);
.generateCombos(@numberOfPlanets);
.generateTernaryCombos(@numberOfPlanets);
//  It first, generates the different mark up combinations and the animation names required. After, it then generates the different keyframes to be used.

.genDepth(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-depth="@{i}"] {
    animation-name: ~'goDeep@{i}';
  }
  @keyframes ~'goDeep@{i}' {
    @depth: (@orbitDepth / @numberOfPlanets) * @i;
    .orbit(@depth, 0, 0);
  }
  .genDepth(@n, (@i + 1));
}

.genHeight(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-height="@{i}"] {
    animation-name: ~'goHigh@{i}';
  }
  @keyframes ~'goHigh@{i}' {
    @height: (@orbitHeight) * @i;
    .orbit(0, 0, @height);
  }
  .genHeight(@n, (@i + 1));
}

.genWidth(@n, @i:1) when (@i <= @n) {
  .orbit .planet[data-orbit-width="@{i}"] {
    animation-name: ~'goWide@{i}';
  }
  @keyframes ~'goWide@{i}' {
    @width: (@orbitWidth/@numberOfPlanets) * @i;
    .orbit(0, @width, 0);
  }
  .genWidth(@n, (@i + 1));
}


// Once we've done singular keyframes then we must think about when we have two attributes defined.
.generateCombos(@n, @i:1) when (@i <= @n) {
  .genCombo(@i);
  .genComboOrbits(@i);
  .generateCombos(@n, (@i + 1));
}

.genCombo(@n, @i: 1) when (@i <= @n) {
  .orbit .planet[data-orbit-width="@{n}"][data-orbit-height="@{i}"] {
    animation-name: ~'goWide@{n}High@{i}';
  }
  .orbit .planet[data-orbit-width="@{n}"][data-orbit-depth="@{i}"] {
    animation-name: ~'goWide@{n}Deep@{i}';
  }
  .orbit .planet[data-orbit-height="@{n}"][data-orbit-width="@{i}"] {
    animation-name: ~'goHigh@{n}Wide@{i}';
  }
  .orbit .planet[data-orbit-height="@{n}"][data-orbit-depth="@{i}"] {
    animation-name: ~'goHigh@{n}Deep@{i}';
  }
  .orbit .planet[data-orbit-depth="@{n}"][data-orbit-height="@{i}"] {
    animation-name: ~'goDeep@{n}High@{i}';
  }
  .orbit .planet[data-orbit-depth="@{n}"][data-orbit-width="@{i}"] {
    animation-name: ~'goDeep@{n}Wide@{i}';
  }
  .genCombo(@n, (@i + 1));
}
// combo orbit keyframes becomes a little more complicated
.genComboOrbits(@n, @i: 1) when (@i <= @n) {
  @keyframes ~'goWide@{n}High@{i}' {
    @height: (@orbitHeight) * @i;
    @width: (@orbitWidth) * @n;
    .orbit(0, @width, @height);
  }
  @keyframes ~'goWide@{n}Deep@{i}' {
    @depth: (@orbitDepth/@numberOfPlanets) * @i;
    @width: (@orbitWidth) * @n;
    .orbit(@depth, @width, 0);
  }
  @keyframes ~'goHigh@{n}Wide@{i}' {
    @height: (@orbitHeight) * @n;
    @width: (@orbitWidth) * @i;
    .orbit(0, @width, @height);
  }
  @keyframes ~'goHigh@{n}Deep@{i}' {
    @height: (@orbitHeight) * @n;
    @depth: (@orbitDepth/@numberOfPlanets) * @i;
    .orbit(@depth, 0, @height);
  }
  @keyframes ~'goDeep@{n}High@{i}' {
    @height: (@orbitHeight) * @i;
    @depth: (@orbitDepth/@numberOfPlanets) * @n;
    .orbit(@depth, 0, @height);
  }
  @keyframes ~'goDeep@{n}Wide@{i}' {
    @depth: (@orbitDepth/@numberOfPlanets) * @n;
    @width: (@orbitWidth) * @i;
    .orbit(@depth, @width, 0);
  }
  .genComboOrbits(@n, (@i + 1));
}

// Lastly, we generate the triple combos where we have three attributes defined.
// It requires three levels of looping in order to achieve this. Not ideal but I still wouldn't want to write it all by hand.
.genTernaryDeep(@turn, @round) {
  .genDeep(@n, @i: 1) when (@i <= @n) {
    .orbit .planet[data-orbit-width="@{turn}"][data-orbit-height="@{n}"][data-orbit-depth="@{i}"] {
      animation-name: ~'goWide@{turn}High@{n}Deep@{i}';
    }
    .orbit .planet[data-orbit-width="@{turn}"][data-orbit-depth="@{n}"][data-orbit-height="@{i}"] {
      animation-name: ~'goWide@{turn}Deep@{n}High@{i}';
    }

    .orbit .planet[data-orbit-height="@{turn}"][data-orbit-width="@{n}"][data-orbit-depth="@{i}"] {
      animation-name: ~'goHigh@{turn}Wide@{n}Deep@{i}';
    }
    .orbit .planet[data-orbit-height="@{turn}"][data-orbit-depth="@{n}"][data-orbit-width="@{i}"] {
      animation-name: ~'goHigh@{turn}Deep@{n}Wide@{i}';
    }

    .orbit .planet[data-orbit-depth="@{turn}"][data-orbit-height="@{n}"][data-orbit-width="@{i}"] {
      animation-name: ~'goDeep@{turn}High@{n}Wide@{i}';
    }
    .orbit .planet[data-orbit-depth="@{turn}"][data-orbit-width="@{n}"][data-orbit-height="@{i}"] {
      animation-name: ~'goDeep@{turn}Wide@{n}High@{i}';
    }
    .genDeep(@n, (@i + 1));
  }
  .genDeep(@round);
}

.genTernary(@n, @i: 1) when (@i <= @n) {
  .genTernaryDeep(@n, @i);
  .genTernary(@n, (@i + 1));
}

.generateTernaryCombos(@n, @i: 1) when (@i <= @n) {
  .genTernary(@i);
  .genTernaryOrbit(@i);
  .generateTernaryCombos(@n, (@i + 1));
}
.genTernaryOrbit(@n, @i: 1) when (@i <= @n) {
  .genTernaryOrbitDeep(@n, @i);
  .genTernaryOrbit(@n, (@i + 1));
}
.genTernaryOrbitDeep(@turn, @round) {
  .genOrbitDeep(@n, @i: 1) when (@i <= @n) {
    @keyframes ~'goWide@{turn}High@{n}Deep@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @i;
      @width: (@orbitWidth) * @turn;
      @height: (@orbitHeight) * @n;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goWide@{turn}Deep@{n}High@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @n;
      @width: (@orbitWidth) * @turn;
      @height: (@orbitHeight) * @i;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goHigh@{turn}Wide@{n}Deep@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @i;
      @width: (@orbitWidth) * @n;
      @height: (@orbitHeight) * @turn;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goHigh@{turn}Deep@{n}Wide@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @n;
      @width: (@orbitWidth) * @i;
      @height: (@orbitHeight) * @turn;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goDeep@{turn}High@{n}Wide@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @turn;
      @width: (@orbitWidth) * @i;
      @height: (@orbitHeight) * @n;
      .orbit(@depth, @width, @height);
    }
    @keyframes ~'goDeep@{turn}Wide@{n}High@{i}' {
      @depth: (@orbitDepth/@numberOfPlanets) * @turn;
      @width: (@orbitWidth) * @n;
      @height: (@orbitHeight) * @i;
      .orbit(@depth, @width, @height);
    }
    .genOrbitDeep(@n, (@i + 1));
  }
  .genOrbitDeep(@round);
}



.orbit(@depth, @width, @height) {
    0% {
      transform: translateZ(@depth / 2) translateX(0) translateY(@height);
    }
    25% {
      transform: translateZ(0) translateX(@width) translateY(0)
    }
    50% {
      transform: translateZ(-@depth / 2) translateX(0) translateY(-@height);
    }
    75% {
      transform: translateZ(0) translateX(-@width) translateY(0);
    }
    100% {
      transform: translateZ(@depth / 2) translateX(0) translateY(@height);
    }
}
